% XWFREQSPECPLOT  Plots cross wavelet frequency spectrum
%   xwfreqspecplot plots the cross wavelet power spectrum of two signals
%   by collapsing the time axis. The figure axes are rotated and placed
%   next to the xwt plot generated by 'session5c_mod' with the frequency
%   axis running along the y-axis for ease of visualization. The program
%   offers a choice of plotting the power on a linear or log scale.

% Last update: 01-Mar-2011 02:40:47
% Author: AP

%% Variables Glossary
% Wxy ==> XWT coefficients. Values are complex numbers whose magnitude
%         cross wavelet power and angle gives the relative phase between
%         the two signals.
% sig95 ==> Matrix the size of Wxy containing numbers indicating how many
%           variances away the corresponding point in Wxy is from a 'red'
%           or 'white' noise background spectrum. For instance, if
%           sig95(4,5)= 3, that implies Wxy(4,5)is 3 variances
%           (95% confidence level) away from noise with the same mean as the
%           time series.
%

%% Wavelet Parameters - Adjustable
Pad = 1; % Zero padding of signals (Pad = 1: Pad with zeroes; Pad = 0: Don't zero pad)
dj = 1/64; % Wavelet scale resolution (Must be at least 1/10)
nPhaseBins = 90; % Number of bins for phase histograms

%% Wavelet Parameters - Derived and Fixed
fourier_factor = 1.0330; % This is the factor into which wavelet scales
% divide to yield frequency values. DO NOT CHANGE THIS VALUE (as long as
% you are using Morlet with wave# = 6)
scaleRange = 1./(freqRange*fourier_factor); % Scale range corresponding to frequency range.
S0 = min(scaleRange);
MaxScale = max(scaleRange);

%% XW Calculations
if freqRange >= floor(1/samplingInt); errordlg('High frequency value above Nyquist limit'), end
lpf = ceil(freqRange(2)/2.5);

%% Signal Reduction Parameters
newSamplingFrequency = max(freqRange(2)*4,20); % This ensures that the new sampling rate is well over twice the largest frequency.

%% Some processing
tempSig = eval(['signal' num2str(dataFiles(1)) ';']);
sigMat = zeros(size(tempSig,1),length(dataFiles),size(tempSig,2)); % Third dimension...
%... of sigMat contain channels, while second the files.
sigmas = zeros(size(sigMat,2),size(sigMat,3));
clear tempSig
for fileNum = dataFiles
    for chNum = 1:size(sigMat,3)
        eval(['sigMat(:,fileNum,chNum)= signal' num2str(fileNum) '(:,chNum);'])
        sigmas(fileNum,chNum) = std(sigMat(:,fileNum,chNum));
    end
end

%% Truncating signal matrix and filtering
if abs(firstTime) > abs(timeRange(1)) % firstTime is computed in "PREPROCESSDATA.m"
    firstTime = timeRange(1);
end
lastTime = timeRange(2);
[sigMat,time_mod] = truncatedata(sigMat,time,[firstTime lastTime]);
time_reduced = time_mod; % This is necessary for session5b/c to run properly afterwards.


%% Convert 3-D matrix of signals into a 2-D matrix
% Converts the 3-D matrix of signals (data points, files, channels) into a
% 2-D matrix of signals (data points, [(n file's channels of file1)
% (n + 1 file's channels)...(Nth file's channels)])

sigMat2 = zeros(size(sigMat,1),size(sigMat,3),size(sigMat,2));
for chNum = 1:size(sigMat,3)
    sigMat2(:,chNum,:) = sigMat(:,:,chNum);
end
sigMat2 =reshape(sigMat2,size(sigMat2,1),size(sigMat2,2)*size(sigMat2,3));
sigMat2 = [time_mod(:) sigMat2];

%% Signal Reduction Parameters
sigMat = reducedata(sigMat,time_mod,newSamplingFrequency);
time_reduced = linspace(0,time_reduced(end)-time_reduced(1),size(sigMat,1));
lenTime  = length(time_reduced);

%% Statistical Parameters
level = 2^2; % (default: level = 2)
threshType = 'sigma'; %('sigma' - thresholds based on std; 'level' -
% thresholds based on level);
stringency = 1; % I made a modification to the code in xwt.m which allows the user to select a region of the time series for which to calculate standard deviation, and therefore this "stringency" value actually reflects the # of standard deviations the activity must be to be considered significant.
if strcmpi(threshType,'level')|| strcmpi(threshType,'sigma')
else
    errordlg('Input for the variable "threshType" not specified properly')
end

%% Trace Display
traceType = 'raw'; % ('raw' - displays the traces under the xwt as raw...
% data highpassed at 50Hz; 'smooth' - dispays as rectified, lowpassed
% traces)
if strcmpi(traceType,'smooth')|| strcmpi(traceType,'raw')
else
    errordlg('Input for the variable "traceType" not specified properly')
end
yShifter = 1.5; %(Factor by which the max value of a trace is multiplied...
% and shifted along the y-axis to prevent overlap; default = 1.5)

%% Phase Display
phaseType = 'all'; % (default = 'alt'; can also be 'synch' or 'all' wherein the displayed phases are in synch or all respectively)
if strcmpi(phaseType,'alt')|| strcmpi(phaseType,'synch') || strcmpi(phaseType,'all')
else
    errordlg('Input for the variable "phaseType" not specified properly')
end

%% Power Spectrum Display
powerSpectrumType = 'both';  %('linear', 'log', 'both', 'none')
if strcmpi(powerSpectrumType,'linear')|| strcmpi(powerSpectrumType,'log') || strcmpi(powerSpectrumType,'both') || strcmpi(powerSpectrumType,'none')
else
    errordlg('Input for the variable "powerSpectrumType" not specified properly')
end
peakDetectionThresh = 0.1; % This determines the amplitude of a peak in the power spectrum for which a frequency value should be displayed. Setting to a low value detects low peaks and displace their corresponding freq values.

%% XWT
statMat = cell(15, size(sigMat,2)*(size(sigMat,3)-1)+1);
statMat(:,1)= deal({'Peak f','Mean f', 'Std f','Peak Ph', 'Mean Ph', 'Std Ph',...
    'Mean Pow','Std Pow','Synch Pow','Alt Pow','Alt Pow/Synch Pow' ,'Tot Pow','Tot Pow Ratio','Time Range','Freq Range'});
chLabelMat =cell(1, size(sigMat,2)*(size(sigMat,3)-1)+1);
chLabelMat{1} = 'Channels';
fNamesMat =cell(1, size(sigMat,2)*(size(sigMat,3)-1)+1);
fNamesMat{1}='File Names';
cellNum = 1;

fileCounter = 0;
for fileNum = 1:size(sigMat,2) % File Number Loop # 1
    fStr =['f' num2str(fileNum)];
    fileCounter = fileCounter + 1;
    for chNum =1:size(sigMat,3)-1 % Channel Number Loop # 1
        chStr = ['ch' num2str(ch(chNum)) num2str(ch(chNum+1))];
        cellNum = cellNum+1;
        
        % Start: Normalizing time-series - Jun 06, 2012
%                 sigMat(:,fileNum,chNum) = std(sigMat(:,fileNum,chNum))* normalizepdf(sigMat(:,fileNum,chNum));
%                 sigMat(:,fileNum,chNum+1) = std(sigMat(:,fileNum,chNum+1))* normalizepdf(sigMat(:,fileNum,chNum+1));
        % End: Normalizing time-series
        
        eval(['[Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...  % XWT ==> Wxy
            ',period,scale,coi,sig95]'...
            '= wtc([time_reduced(:) sigMat(:,fileNum,chNum)]'...
            ',[time_reduced(:) sigMat(:,fileNum,chNum+1)]'...
            ',Pad, dj,''S0'',S0, ''ms'',MaxScale, ''Mother'', ''Morlet'');'])
        
%          eval(['[Rsq_f' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...  % WTC ==> Rsq (see Grinsted et al, 2004, eqn 8)
%             ',period_r,scale_r,coi_r,sig95_r]'...
%             '= wtc([time_reduced(:) sigMat(:,fileNum,chNum)]'...
%             ',[time_reduced(:) sigMat(:,fileNum,chNum+1)]'...
%             ',Pad, dj,''S0'',S0, ''ms'',MaxScale, ''Mother'', ''Morlet'');']);
        
        eval(['sig95' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1) '= sig95;'])
        freq =1./period;
        ftmat = repmat(freq(:), 1, lenTime);
        coimat = repmat(1./coi(:)',length(freq), 1);
        eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
            '_coi = Wf' num2str(fileNum) 'ch' num2str(chNum)...
            num2str(chNum+1) ';'])
        %         eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
        %             '_coi(ftmat<coimat) = 0;'])
        eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
            '_coi_sig = Wf' num2str(fileNum) 'ch'  num2str(chNum)...
            num2str(chNum+1) '_coi;'])
        
        %% Sigma or Level Based Thresholding
        if strcmpi(threshType,'sigma')
            eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
                '_coi_sig(sig95 < stringency) = 0;']) % (default: sig95 < 1)
        elseif strcmpi(threshType,'level')
            Wxy = eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
                '_coi_sig;']);
            eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
                '_coi_sig(abs(Wxy)<level) = 0;'])% Keeps only those values
            % which are above a certain specified cross power 'level'
            
        end
        Wxy = eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
            '_coi_sig;']);
        
        %% Angle Based Filtering
        a  = angle(Wxy);
        switch phaseType
            case 'alt'
                Wxy(abs(a)<=pi/2)=0; % Keeps only those matrix elements with angles <= pi/2
                eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
                    '_coi_sig_alt = Wxy;']) % abs(a)is necessary b/c angle(mat)outputs -ve values as well
            case 'synch'
                Wxy(abs(a)>pi/2)=0; % Keeps only those matrix elements with angles <= pi/2
                eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
                    '_coi_sig_alt = Wxy;']) % abs(a)is necessary b/c angle(mat)outputs -ve values as well
            case 'all'
                eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
                    '_coi_sig_alt = Wxy;'])
        end
        
        %% Frequencies, Phases, XW Powers, Etc
        %       Wxy_bin =Wxy; Wxy_bin(Wxy~=0)=1; % Wxy_bin is a binary matrix created by substituting unity for all non-zero values in Wxy
        Wxy_prob = abs(Wxy./sum(Wxy(:))); % Each entry in Wxy is expressed as the probability of occurrence of that value within the distribution of all values of Wxy to create Wxy_prob
        
        
        % Calculating mean & std of frequencies
        Wxy_s = sum(Wxy_prob,2);
        meanFreqs.(fStr).(chStr) = round((freq(:)'*Wxy_s)*100)/100; % Mean frequency is obtained by weighting the frequency coordinate of each value in Wxy with the corresponding value in Wxy_prob and taking the sum of all these values
        Fxy = ftmat; Fxy(Wxy==0)=0;
        Fxy_prob = Fxy.*Wxy_prob;
        Fxy_prob(Fxy_prob==0)=[];
        mf = mean(Fxy_prob);
        sf = std(Fxy_prob);
        stdFreqs.(fStr).(chStr) = sf * meanFreqs.(fStr).(chStr)/mf;
        stdFreqs.(fStr).(chStr) = round(stdFreqs.(fStr).(chStr)*100)/100;
        
        % Calculating XW power spectrum & Peak Frequency(frequency at which coherent power is highest)
        power_distribution_along_freq_axis.(fStr).(chStr) = sum(abs(Wxy),2);
        norm_power_distribution_along_freq_axis.(fStr).(chStr) =...
            power_distribution_along_freq_axis.(fStr).(chStr)/...
            max(power_distribution_along_freq_axis.(fStr).(chStr)); % Power units indicate cumulative probability
        normlog_power_distribution_along_freq_axis.(fStr).(chStr) = ...
            log2(power_distribution_along_freq_axis.(fStr).(chStr));
        normlog_power_distribution_along_freq_axis.(fStr).(chStr) = ...
            normlog_power_distribution_along_freq_axis.(fStr).(chStr)/max(normlog_power_distribution_along_freq_axis.(fStr).(chStr));
        [maxtab,mintab] = peakdet(norm_power_distribution_along_freq_axis.(fStr).(chStr),peakDetectionThresh);
        
        if numel(maxtab) == 0
            maxtab(:,1)= find(norm_power_distribution_along_freq_axis.(fStr).(chStr) == max(norm_power_distribution_along_freq_axis.(fStr).(chStr)));
            maxtab(:,2)= norm_power_distribution_along_freq_axis.(fStr).(chStr)(maxtab(:,1));
        end
        
        pv = find(maxtab(:,2)== max(maxtab(:,2)));
        pf = round(freq(maxtab(pv,1))*100)/100;
        
        if isempty(pv) | isempty(pf)
            maxtab =[1 1+i];
            pv = 1
            pf= 1+i;
        end
        % Calculating mean and std of phases within significant regions
        Wxy_nonzero_lin = Wxy; Wxy_nonzero_lin(Wxy==0)=[]; % This removes all zero elements from the matrix and vectorizes it.
        Axy = angle(Wxy_nonzero_lin); % Axy will also be a vector now
        
        mphase = circ_mean(Axy(:),abs(Wxy_nonzero_lin(:)));
        %%%%% Alternatively, mphase = angle(sum(Wxy_nonzero_lin));
        mphase(mphase<0) = mphase(mphase<0)+ 2*pi; % Addition of 2*pi to -ve values converts angle range from 0 to 360 rather than -180 to +180
        meanPhases.(fStr).(chStr) = mphase*180/pi; % Converts radians to degrees.
        meanPhases.(fStr).(chStr) = round(meanPhases.(fStr).(chStr)*100)/100;
        sphase = circ_std(Axy(:),abs(Wxy_nonzero_lin(:)));
        stdPhases.(fStr).(chStr) = sphase*180/pi;
        stdPhases.(fStr).(chStr) = round(stdPhases.(fStr).(chStr)*100)/100;
        [ph_dist,th] = hist(Axy(:),nPhaseBins);
        pow_dist = hist(abs(Wxy_nonzero_lin(:)),nPhaseBins);
        [sortph,ind] = sort(Axy(:));
        Z = abs(Wxy_nonzero_lin(:));
        histWxy = Z(ind); histWxy = decimate(histWxy,floor(length(Z)/nPhaseBins));
        histWxy = histWxy(1:nPhaseBins);
        ph_dist_wt = ph_dist(:).*histWxy(:);
        
        ph_dist = [ph_dist(:); ph_dist(1)]; % This will close the loop in polar plot by circularizing the vector.
        ph_dist_wt = [ ph_dist_wt(:); ph_dist_wt(1)];
        phase_dist.(fStr).(chStr) = ph_dist./max(ph_dist);
        phase_dist_weight.(fStr).(chStr) = ph_dist_wt./max(ph_dist_wt);
        theta.(fStr).(chStr) = [th(:);th(1)];
        phf = find(phase_dist_weight.(fStr).(chStr)==max(phase_dist_weight.(fStr).(chStr)));
        if numel(phf)~=0
            phf = phf(1);
        else phf = 1;
        end
        peakPhase.(fStr).(chStr) = round(theta.(fStr).(chStr)(phf)*180/pi);
        if peakPhase.(fStr).(chStr)<0, peakPhase.(fStr).(chStr) = peakPhase.(fStr).(chStr)+360; end
        
        % Calculating mean and std of xw power in significant regions
        altPhases = find(angle(Wxy_nonzero_lin)>pi/2 | angle(Wxy_nonzero_lin)< -pi/2);
        synchPhases = find(angle(Wxy_nonzero_lin)<= pi/2 & angle(Wxy_nonzero_lin)>= -pi/2);
        sblah = abs(Wxy_nonzero_lin(synchPhases));
        synchPowers.(fStr).(chStr) = round(sum(sblah(:))*100)/100;
        ablah = abs(Wxy_nonzero_lin(altPhases));
        altPowers.(fStr).(chStr) = round(sum(ablah(:))*100)/100;
        meanPowers.(fStr).(chStr) = round(mean(abs(Wxy(:)))*100)/100;
        stdPowers.(fStr).(chStr) = round(std(abs(Wxy(:)))*100)/100;
        totalPowers.(fStr).(chStr) = round(sum(abs(Wxy(:))));
        altSynchPowRatio.(fStr).(chStr) = round((altPowers.(fStr).(chStr)/synchPowers.(fStr).(chStr))*100)/100;
        if round(totalPowers.(fStr).(chStr)-(synchPowers.(fStr).(chStr)+ altPowers.(fStr).(chStr)))>10
            errordlg('Synch Pow + Alt Pow ~= Tot Pow');
        end
        if cellNum==2
            firstPow = totalPowers.(fStr).(chStr);
        end
        totPowRatio.(fStr).(chStr) = round(100*totalPowers.(fStr).(chStr)/firstPow)/100;
        statMat(:,cellNum)= deal({pf, meanFreqs.(fStr).(chStr),...
            stdFreqs.(fStr).(chStr),peakPhase.(fStr).(chStr),meanPhases.(fStr).(chStr),...
            stdPhases.(fStr).(chStr),meanPowers.(fStr).(chStr),...
            stdPowers.(fStr).(chStr),synchPowers.(fStr).(chStr),...
            altPowers.(fStr).(chStr),altSynchPowRatio.(fStr).(chStr),totalPowers.(fStr).(chStr),...
            totPowRatio.(fStr).(chStr),num2str(timeRange),num2str(freqRange)});
        chLabelMat{cellNum} = ['f' num2str(fileNum) ' ch' num2str(ch(chNum))...
            num2str(ch(chNum+1))];
        fNamesMat{cellNum} = fNames(fileNum,:);
        
        
        
        %% Plotting Figures
        figure('Name', ['XW Power, File ' num2str(fileNum) ', Channels '...
            num2str(ch(chNum)) ' vs ' num2str(ch(chNum+1))],'color','w')
        figPos = get(gcf,'position');
        if strcmpi(powerSpectrumType,'none')
            set(gcf,'position',[figPos(1)*0.6 figPos(2)-figPos(4)/2 figPos(3)*1.3...
                figPos(4)*2]);
        else
            set(gcf,'position',[figPos(1)*0.6 figPos(2)-figPos(4)/2 figPos(3)* 1.7...
                figPos(4)*1.5]);
        end
        %% XWT Axes
        ax1 = axes; box off
        aPos = get(ax1,'position');
        if strcmpi(powerSpectrumType,'none')
            aPos = [aPos(1)*0.8 aPos(2)+ aPos(4)*(1/3) aPos(3) aPos(4)*0.75];
        else
            aPos = [aPos(1)*0.8 aPos(2)+ aPos(4)*(1/3) aPos(3)*(0.95) aPos(4)*0.75];
        end
        set(ax1,'position', aPos)
        sig95 = eval(['sig95' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1) '']);
        Wxy = eval(['Wf' num2str(fileNum) 'ch' num2str(chNum)...
            num2str(chNum+1) '_coi_sig_alt']);
        plotwave(Wxy,time_reduced,period,coi,sig95,...
            sigmas(fileNum,chNum), sigmas(fileNum,chNum+1))
        set(ax1,'color','k','xtick',[], 'xcolor','w','ycolor','k')
        xlim([time_reduced(1) time_reduced(end)]) %%%% This line is NECESSARY to ensure that x-axis is aligned with traces below
        xlabel('')
        ylims1 = get(ax1,'ylim');
        yticklabels_ax1 = str2num(get(ax1,'yticklabel'));
        dyticklabels_ax1 = diff(yticklabels_ax1);
        if numel(dyticklabels_ax1)==1,yScale = 'log';
        elseif dyticklabels_ax1(1)== dyticklabels_ax1(2), yScale = 'linear';
        else yScale = 'log';
        end
        yl = ylabel('Frequency (Hz)','fontsize',14);
        ylpos = get(yl,'pos');
        aPos = get(ax1,'position');
        
        %% XW Power Spectrum Axes
        if strcmpi(powerSpectrumType,'none')
        else
            ax2 = axes; hold on, box off
            aPos2 = get(ax2,'pos');
            aPos2 = [aPos(1) + aPos(3) aPos(2) aPos2(3)*(0.15) aPos(4)];
            set(ax2,'pos', aPos2, 'color','none','tickdir','out','fontsize',11);
            xlabel([{'Normalized'}; {'Power'}])
            if imag(maxtab(:,2))
                maxtab(:,2)= 1+i;
                peakFreqs = 1+i;
            else
                peakFreqs = freq(maxtab(:,1));
            end
            if strcmpi(yScale,'linear')
                logPeakFreqs = peakFreqs;
                freq2 = freq;
            else
                logPeakFreqs = log2(peakFreqs);
                freq2 = log2(freq);
            end
            switch powerSpectrumType
                case 'linear'
                    plot(norm_power_distribution_along_freq_axis.(fStr).(chStr),freq2,'k','linewidth',2)
                    leg = {'Linear Spectrum'}
                case 'log'
                    plot(normlog_power_distribution_along_freq_axis.(fStr).(chStr),freq2,'k','linewidth',2)
                    set(ax2,'xtick',[],'xcolor','w')
                    leg = {'Log Spectrum'};
                    ax2b = axes('position',aPos2,'xaxislocation','bottom',...
                        'yaxislocation','right','color','none','xscale','log','ytick',[],'ycolor','k','fontsize',11);
                    xt = [0.25 0.5 1];
                    set(ax2b,'xtick',xt);
                    xlabel([{'Normalized'}; {'Power'}])
                case 'both'
                    plot(norm_power_distribution_along_freq_axis.(fStr).(chStr), freq2,'k','linewidth',2)
                    plot(normlog_power_distribution_along_freq_axis.(fStr).(chStr), freq2,'k:','linewidth',2,'parent',ax2)
                    leg ={'Linear'; 'Log'};
                    ax2b = axes('position',aPos2,'xaxislocation','top',...
                        'yaxislocation','right','tickdir','out','color','none','xscale','log','ytick',[],'ycolor','w','fontsize',11);
                    xt = [0.25 0.5 1];
                    set(ax2b,'xtick',xt,'xlim',[0 1]);
                    hold off
            end
            
            set(ax2,'ylim',ylims1,'xlim',[0 1],'xtick',[0.5 1],'ytick',[])
            xvals = 0.35*ones(size(peakFreqs));
            
            clear txt
            for pf = 1:length(peakFreqs)
                txt{pf} = [num2str(round(peakFreqs(pf)*100)/100) ' Hz'];
                % txt = {round(peakFreqs*100)/100};
            end
            
            text(xvals,logPeakFreqs,txt,'fontsize',11,'color','r','parent',ax2);
            legend(ax2,leg,'fontsize',10) % This line needs to be here to legend can be moved by hand after fig is generated
            
            
        end
        %% Time Series Axes
        ax3=axes; hold on, box off
        aPos3 = get(ax3,'position');
        aPos3 = [aPos(1) aPos3(2) aPos(3) aPos3(4)*(1/3)];
        set(ax3,'position',aPos3,'tickdir','out','color','w','ycolor','w');
        switch traceType
            case 'raw'
                fstr = num2str(fileNum);
                tempSig = eval(['temp' num2str(fileNum) '(:,chNum);']);
                %                 tempSig = zscore(truncatedata(tempSig,time,[firstTime lastTime]));
                tempSig = truncatedata(tempSig,time,[firstTime lastTime]);
                
                tempTime = linspace(0,time_reduced(end),length(tempSig))...
                    + firstTime; % Adding firstTime to the time vector here
                % will set the time of the first stimulus in the stimulus
                % train to a value of zero
                
                plot(tempTime,tempSig + (yShifter/2)*max(tempSig),'k','linewidth',1.5)
                tempSig = eval(['temp' num2str(fileNum) '(:,chNum+1);']);
                %                 tempSig = zscore(truncatedata(tempSig,time,[firstTime lastTime]));
                tempSig = truncatedata(tempSig,time,[firstTime lastTime]);
                plot(tempTime,tempSig-(yShifter/2)*max(tempSig),...
                    'k','linewidth',1.5)
                
            case 'smooth'
                tempSig(:,chNum) = zscore(sigMat(:,fileNum,chNum));
                tempTime = linspace(0,time_reduced(end),length(tempSig))...
                    + firstTime; % Adding firstTime to the time vector here
                % will set the time of the first stimulus in the stimulus
                % train to a value of zero
                %                 plot(tempTime,tempSig(:,chNum),colors(chNum),'linewidth',1.5)
                plot(tempTime,tempSig(:,chNum)+2.5,'k','linewidth',1.5)
                tempSig(:,chNum+1) = zscore(sigMat(:,fileNum,chNum+1));
                plot(tempTime,tempSig(:,chNum+1)-2.5,'k','linewidth',1.5)
        end
        yl2 = ylabel([{'Normalized'};{'Amplitude'}],'fontsize',14,'color','k');
        ylpos2 = get(yl2,'pos');
        ylpos2_mod = ylpos2;
        ylpos2_mod(1) = tempTime(1)-abs(ylpos(1))+ 0.65; ylpos2_mod(2)=0;
        set(yl2,'pos',ylpos2_mod);
        %                     xticks = get(ax3,'xtick');
        set(ax3,'ytick',[])
        axis([tempTime(1) tempTime(end) -inf inf])
        stimtrain % Running this program generates 'tStimArts' a vector of stimulus artifact times
        xlabel(['Stim Train (' num2str(stimDur) 'sec) @ ' num2str(stimFreq) ' Hz'],'fontsize',14)
        set(gca,'fontsize',14)
        set(ax3,'ytick',[],'xtick',[tStimArts - tStimArts(1)],'xticklabel',[])
        hold off;
    end
end

%% Storing the statistics into an excel file
statMat =[chLabelMat; statMat; fNamesMat];
labCompSid = 'S-1-5-21-12604286-656692736-1848903544';
% myLaptopSid = 'S-1-5-21-2395549063-1654931228-1756539298'; % Dell E1505
myLaptopSid = 'S-1-5-21-3197369867-541179473-1092110829'; % Dell XPS
sid =getsid;
strangeCompCheck =0;
switch sid
    case labCompSid
        [success, message] = ...
            xlswrite('C:\Documents and Settings\pujalaav.nih\My Documents/temp.xls',statMat);
        if success
            'Data has been written to temp in My Documents'
        else
            errordlg('Data writing failed! Excel file must be closed for writing data')
        end
    case myLaptopSid
        [success,message]= ...
            xlswrite('C:\Users\Avi\Documents\temp.xls',statMat);
        
        if success
            'Data has been written to temp in My Documents'
        else
            errordlg('Data writing failed! Excel file must be closed for writing data')
        end
    otherwise
        'This is not your lab or home computer, so data has not been written'
        strangeCompCheck = 1;
end
ButtonName = questdlg('Plot rose diagrams?', ...
    'Phase distribution', ...
    'Yes', 'No', 'No');
switch ButtonName,
    case 'Yes',
        plotphase
    case 'No',
end %

%% Bug Fixes
% 1) XWT plot time axis was misaligned by a slight bit with Time Series
% plot time axes. Fixed by setting xlims for each axis
% 2) Found a way to adjust position of ylabels so that they align for
% vertically juxtaposed axes (2.11.11)


%% Pending fixes
% 1) Inscribing 'Power' on colorbar? - I can always do this using 'text'
% function
% 2) Ideally, the two signals need to be normalized using normalizepdf.m
%   provided by Grinsted if the histogram deviates severely from normal.
% 3) Verify logic for stdFreqs
% 4) Since sig regions are affected by length of signal it might be
% beneficial to select a region of the signals from which to calculate
% sigmax and sigmay


% Related Code
% STIMTRAIN - Generates a stim train
% PLOTPHASES - Plots of phase distributions