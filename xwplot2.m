% XWFREQSPECPLOT  Plots cross wavelet frequency spectrum
%   xwfreqspecplot plots the cross wavelet power spectrum of two signals
%   by collapsing the time axis. The figure axes are rotated and placed
%   next to the xwt plot generated by 'session5c_mod' with the frequency
%   axis running along the y-axis for ease of visualization. The program
%   offers a choice of plotting the power on a linear or log scale.

% Last update: 01-Mar-2011 02:40:47
% Author: AP

%% Variables Glossary
% Wxy ==> XWT coefficients. Values are complex numbers whose magnitude
%         cross wavelet power and angle gives the relative phase between
%         the two signals.
% sig95 ==> Matrix the size of Wxy containing numbers indicating how many
%           variances away the corresponding point in Wxy is from a 'red'
%           or 'white' noise background spectrum. For instance, if
%           sig95(4,5)= 3, that implies Wxy(4,5)is 3 variances
%           (95% confidence level) away from noise with the same mean as the
%           time series.
%

%% Adjustable parameters

freqRange = [0.05 10]; % Range of frequencies to be displayed in XWT
phaseType = 'all'; % 'all' - displays all phases; 
                   % 'alt' - displays alternating phases only
                  % 'synch' - displays synchronous phases only

traceType = 'raw'; % 'raw'    - displays signals as raw traces 
                   % 'smooth' - dispays as rectified, lowpassed traces

wavelet_scale_resolution = 1/64; % (Must at least be 1/10)
number_of_phase_bins = 90; % Number of bins for phase histograms







%%  OPTIONS                 

Pad = 1; % Zero padding of signals (Pad = 1: Pad with zeroes; Pad = 0: Don't zero pad)
dj = wavelet_scale_resolution; % Wavelet scale resolution (Must be at least 1/10)
nPhaseBins = number_of_phase_bins; % Number of bins for phase histograms

time_axis_xticks = 'regular'; %('train' - displays the stimulus train, 'regular' - displays time regularly; default:'train')
figdisp = 'y'; %%% ('n' = does not display figures; [] = displays figs );


%% Wavelet Parameters - Derived and Fixed
fourier_factor = 1.0330; % This is the factor into which wavelet scales
% divide to yield frequency values. DO NOT CHANGE THIS VALUE (as long as
% you are using Morlet with wave# = 6)
scaleRange = 1./(freqRange*fourier_factor); % Scale range corresponding to frequency range.
S0 = min(scaleRange);
MaxScale = max(scaleRange);

%% XW Calculations
if freqRange(2) >= floor(1/samplingInt); errordlg('High frequency value above Nyquist limit'), end
lpf = ceil(freqRange(2)/2.5);

%% Signal Reduction Parameters
newSamplingFrequency = max(freqRange(2)*3,20); % This ensures that the new sampling rate is well over twice the largest frequency.

%% Some processing
tempSig = eval(['signal' num2str(1) ';']);
sigMat = zeros(size(tempSig,1),length(dataFiles),size(tempSig,2)); % Third dimension...
%... of sigMat contain channels, while second the files.
sigmas = zeros(size(sigMat,2),size(sigMat,3));
clear tempSig
for fileNum = dataFiles
    for chNum = 1:size(sigMat,3)
        eval(['sigMat(:,fileNum,chNum)= signal' num2str(fileNum) '(:,chNum);'])
        sigmas(fileNum,chNum) = std(sigMat(:,fileNum,chNum));
    end
end

%% Truncating the signal matrix and filtering
firstTime = time(1); lastTime = time(end);
time_reduced = time;


%% Convert 3-D matrix of signals into a 2-D matrix
% Converts the 3-D matrix of signals (data points, files, channels) into a
% 2-D matrix of signals (data points, [(n file's channels of file1)
% (n + 1 file's channels)...(Nth file's channels)])

sigMat2 = zeros(size(sigMat,1),size(sigMat,3),size(sigMat,2));
for chNum = 1:size(sigMat,3)
    sigMat2(:,chNum,:) = sigMat(:,:,chNum);
end
sigMat2 =reshape(sigMat2,size(sigMat2,1),size(sigMat2,2)*size(sigMat2,3));
sigMat2 = [time_reduced(:) sigMat2];

%% SIGNAL REDUCTION PARAMETERS
sigMat = reducedata(sigMat,time_reduced,newSamplingFrequency);
time_reduced = linspace(time(1),time(end),size(sigMat,1));
dtr = time_reduced(2)-time_reduced(1);
endPt = time_reduced(1)+ (dtr*length(time_reduced));
time_reduced = time_reduced(1):dtr:endPt-dtr; %%% This step is necessary to ensure equal timesteps within time_reduced!!!
lenTime  = length(time_reduced);

%% STATISTICAL PARAMETERS
level = 2^2; % (default: level = 2)
threshType = 'sigma'; %('sigma' - thresholds based on std; 'level' -
% thresholds based on level);
stringency = 1; % I made a modification to the code in xwt.m which allows the user to select a region of the time series for which to calculate standard deviation, and therefore this "stringency" value actually reflects the # of standard deviations the activity must be to be considered significant.
if strcmpi(threshType,'level')|| strcmpi(threshType,'sigma')
else
    errordlg('Input for the variable "threshType" not specified properly')
end

%% TRACE DISPLAY
if strcmpi(traceType,'smooth')|| strcmpi(traceType,'raw')
else
    errordlg('Input for the variable "traceType" not specified properly')
end
yShifter = 1.5; %(Factor by which the max value of a trace is multiplied...
% and shifted along the y-axis to prevent overlap; default = 1.5)

%% PHASE DISPLAY
if strcmpi(phaseType,'alt')|| strcmpi(phaseType,'synch') || strcmpi(phaseType,'all')
else
    errordlg('Input for the variable "phaseType" not specified properly')
end

%% POWER SPECTRUM DISPLAY
powerSpectrumType = 'both';  %('linear', 'log', 'both', 'none')
if strcmpi(powerSpectrumType,'linear')|| strcmpi(powerSpectrumType,'log') || strcmpi(powerSpectrumType,'both') || strcmpi(powerSpectrumType,'none')
else
    errordlg('Input for the variable "powerSpectrumType" not specified properly')
end
peakDetectionThresh = 0.1; % This determines the amplitude of a peak in the power spectrum for which a frequency value should be displayed. Setting to a low value detects low peaks and displace their corresponding freq values.

%% XWT
statMat = cell(15, size(sigMat,2)*(size(sigMat,3)-1)+1);
statMat(:,1)= deal({'Peak f','Mean f', 'Std f','Peak Ph', 'Mean Ph', 'Std Ph',...
    'Mean Pow','Std Pow','Synch Pow','Alt Pow','Alt Pow/Synch Pow' ,'Tot Pow','Tot Pow Ratio','Time Range','Freq Range'});
chLabelMat =cell(1, size(sigMat,2)*(size(sigMat,3)-1)+1);
chLabelMat{1} = 'Channels';
fNamesMat =cell(1, size(sigMat,2)*(size(sigMat,3)-1)+1);
fNamesMat{1}='File Names';
cellNum = 1;
time_varying_power_mat =[];
fileCounter = 0;

for fileNum = 1:size(sigMat,2) % File Number Loop # 1
    fStr =['f' num2str(fileNum)];
    fileCounter = fileCounter + 1;
    chNum =[];
    for chNum =1:size(sigMat,3)-1 % Channel Number Loop # 1
        chStr = ['ch' num2str(ch(chNum)) num2str(ch(chNum+1))];
        cellNum = cellNum+1;
        
        % Start: Normalizing time-series - Jun 06, 2012
        %                 sigMat(:,fileNum,chNum) = std(sigMat(:,fileNum,chNum))* normalizepdf(sigMat(:,fileNum,chNum));
        %                 sigMat(:,fileNum,chNum+1) = std(sigMat(:,fileNum,chNum+1))* normalizepdf(sigMat(:,fileNum,chNum+1));
        % End: Normalizing time-series
        
        eval(['[Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...  % XWT ==> Wxy
            ',period,scale,coi,sig95]'...
            '= xwt([time_reduced(:) sigMat(:,fileNum,chNum)]'...
            ',[time_reduced(:) sigMat(:,fileNum,chNum+1)]'...
            ',Pad, dj,''S0'',S0, ''ms'',MaxScale, ''Mother'', ''Morlet'');'])
        
        %          eval(['[Rsq_f' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...  % WTC ==> Rsq (see Grinsted et al, 2004, eqn 8)
        %             ',period_r,scale_r,coi_r,sig95_r]'...
        %             '= wtc([time_reduced(:) sigMat(:,fileNum,chNum)]'...
        %             ',[time_reduced(:) sigMat(:,fileNum,chNum+1)]'...
        %             ',Pad, dj,''S0'',S0, ''ms'',MaxScale, ''Mother'', ''Morlet'');']);
        
        eval(['sig95' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1) '= sig95;'])
        freq =1./period;
        ftmat = repmat(freq(:), 1, lenTime);
        coimat = repmat(1./coi(:)',length(freq), 1);
        eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
            '_coi = Wf' num2str(fileNum) 'ch' num2str(chNum)...
            num2str(chNum+1) ';'])
        eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
            '_coi(ftmat<coimat) = 0;'])
        eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
            '_coi_sig = Wf' num2str(fileNum) 'ch'  num2str(chNum)...
            num2str(chNum+1) '_coi;'])
        
        %% SIGMA OR LEVEL-BASED THRESHOLDING
        if strcmpi(threshType,'sigma')
            eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
                '_coi_sig(sig95 < stringency) = 0;']) % (default: sig95 < 1)
        elseif strcmpi(threshType,'level')
            Wxy = eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
                '_coi_sig;']);
            eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
                '_coi_sig(abs(Wxy)<level) = 0;'])% Keeps only those values
            % which are above a certain specified cross power 'level'
            
        end
        
        Wxy = eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
            '_coi_sig;']);
        
        %% PHASE-BASED FILTERING
        a  = angle(Wxy);
        switch phaseType
            case 'alt'
                Wxy(abs(a)<=(0.5*pi))=0; % Keeps only those matrix elements with angles >= (0.75*pi) = 135 deg
                eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
                    '_coi_sig_alt = Wxy;']) % abs(a)is necessary b/c angle(mat)outputs -ve values as well
            case 'synch'
                Wxy(abs(a)>pi/2)=0; % Keeps only those matrix elements with angles <= pi/2
                eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
                    '_coi_sig_alt = Wxy;']) % abs(a)is necessary b/c angle(mat)outputs -ve values as well
            case 'all'
                eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
                    '_coi_sig_alt = Wxy;'])
        end
        Wxy = eval(['Wf' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1)...
            '_coi_sig_alt;']);
        
        %% FREQUENCIES, PHASES, XW POWERS, ETC
        %       Wxy_bin =Wxy; Wxy_bin(Wxy~=0)=1; % Wxy_bin is a binary matrix created by substituting unity for all non-zero values in Wxy
        Wxy_prob = abs(Wxy./sum(Wxy(:))); % Each entry in Wxy is expressed as the probability of occurrence of that value within the distribution of all values of Wxy to create Wxy_prob
        if all(isnan(Wxy_prob(:)))
            Wxy_prob = zeros(size(Wxy_prob));
        end
    
        % Calculating mean & std of frequencies
        Wxy_s = sum(Wxy_prob,2);
        meanFreqs.(fStr).(chStr) = round((freq(:)'*Wxy_s)*100)/100; % Mean frequency is obtained by weighting the frequency coordinate of each value in Wxy with the corresponding value in Wxy_prob and taking the sum of all these values
        Fxy = ftmat; Fxy(Wxy==0)=0;
        Fxy_prob = Fxy.*Wxy_prob;
        Fxy_prob(Fxy_prob==0)=[];
        mf = mean(Fxy_prob);
        sf = std(Fxy_prob);
        stdFreqs.(fStr).(chStr) = sf * meanFreqs.(fStr).(chStr)/mf;
        stdFreqs.(fStr).(chStr) = round(stdFreqs.(fStr).(chStr)*100)/100;
        
        % Calculating XW power spectrum & Peak Frequency(frequency at which coherent power is highest)
        power_distribution_along_freq_axis.(fStr).(chStr) = sum(abs(Wxy),2);
        norm_power_distribution_along_freq_axis.(fStr).(chStr) =...
            power_distribution_along_freq_axis.(fStr).(chStr)/...
            max(power_distribution_along_freq_axis.(fStr).(chStr)); % Power units indicate cumulative probability
        normlog_power_distribution_along_freq_axis.(fStr).(chStr) = ...
            log2(power_distribution_along_freq_axis.(fStr).(chStr));
        normlog_power_distribution_along_freq_axis.(fStr).(chStr) = ...
            normlog_power_distribution_along_freq_axis.(fStr).(chStr)/max(normlog_power_distribution_along_freq_axis.(fStr).(chStr));
        [maxtab,mintab] = peakdet(norm_power_distribution_along_freq_axis.(fStr).(chStr),peakDetectionThresh);
        
        if numel(maxtab) == 0
            maxtab(:,1)= find(norm_power_distribution_along_freq_axis.(fStr).(chStr) == max(norm_power_distribution_along_freq_axis.(fStr).(chStr)));
            maxtab(:,2)= norm_power_distribution_along_freq_axis.(fStr).(chStr)(maxtab(:,1));
        end
        
        pv = find(maxtab(:,2)== max(maxtab(:,2)));
        pf = round(freq(maxtab(pv,1))*100)/100;
        
        if isempty(pv) || isempty(pf)
            maxtab =[1 1+i];
            pv = 1;
            pf= 1+i;
        end
        % Calculating mean and std of phases within significant regions
        Wxy_nonzero_lin = Wxy; Wxy_nonzero_lin(Wxy==0)=[]; % This removes all zero elements from the matrix and vectorizes it.
        if isempty(Wxy_nonzero_lin)
            Wxy_nonzero_lin = rand(10,1)*(1+i);
        end
        Axy = angle(Wxy_nonzero_lin); % Axy will also be a vector now       
        nPhaseBins = min([numel(Axy), 90]);
        mphase = circ_mean(Axy(:),abs(Wxy_nonzero_lin(:)));
        %%%%% Alternatively, mphase = angle(sum(Wxy_nonzero_lin));
        mphase(mphase<0) = mphase(mphase<0)+ 2*pi; % Addition of 2*pi to -ve values converts angle range from 0 to 360 rather than -180 to +180
        meanPhases.(fStr).(chStr) = mphase*180/pi; % Converts radians to degrees.
        meanPhases.(fStr).(chStr) = round(meanPhases.(fStr).(chStr)*100)/100;
        sphase = circ_std(Axy(:),abs(Wxy_nonzero_lin(:)));
        stdPhases.(fStr).(chStr) = sphase*180/pi;
        stdPhases.(fStr).(chStr) = round(stdPhases.(fStr).(chStr)*100)/100;
        [ph_dist,th] = hist(Axy(:),nPhaseBins);
        mag = abs(Wxy_nonzero_lin);
        mat = [Axy(:) mag(:)];
        [ph_dist3,vals] = hist3(mat,[nPhaseBins,nPhaseBins]);
        powmat = repmat(vals{2},size(ph_dist3,1),1);
        ph_dist_wt = ph_dist3.*powmat;
        ph_dist_wt = sum(ph_dist_wt,2)';
%        

%         pow_dist = hist(abs(Wxy_nonzero_lin(:)),nPhaseBins);
        
        %         [sortph,ind] = sort(Axy(:));
        %         Z = abs(Wxy_nonzero_lin); Z = Z(:);
        %         histWxy = Z(ind); % This essentially amounts to sorting by the ascending order of values in Axy
        %         num_phases_per_bin = floor(numel(histWxy)/nPhaseBins);
        %         histWxy = decimate(histWxy(:),num_phases_per_bin);
        %         histWxy = histWxy(1:nPhaseBins);
        
%         ph_dist_wt = ph_dist(:).*pow_dist(:);
        if isempty(ph_dist)
            theta.(fStr).(chStr) = zeros(size(ph_dist_wt));
        else
            ph_dist = [ph_dist(:); ph_dist(1)]; % This will close the loop in polar plot by circularizing the vector.
            ph_dist_wt = [ ph_dist_wt(:); ph_dist_wt(1)];
            phase_dist.(fStr).(chStr) = ph_dist./max(ph_dist);
            phase_dist_weight.(fStr).(chStr) = ph_dist_wt./max(ph_dist_wt);
            theta.(fStr).(chStr) = [th(:);th(1)];
            phf = find(phase_dist_weight.(fStr).(chStr)==max(phase_dist_weight.(fStr).(chStr)));
            if numel(phf)~=0
                phf = phf(1);
            else phf = 1;
            end           
        end        
         peakPhase.(fStr).(chStr) = round(theta.(fStr).(chStr)(phf)*180/pi);
        if peakPhase.(fStr).(chStr)<0, peakPhase.(fStr).(chStr) = peakPhase.(fStr).(chStr)+360; end
           
        % Calculating mean and std of xw power in significant regions
        altPhases = find(angle(Wxy_nonzero_lin)>pi/2 | angle(Wxy_nonzero_lin)< -pi/2);
        synchPhases = find(angle(Wxy_nonzero_lin)<= pi/2 & angle(Wxy_nonzero_lin)>= -pi/2);
        sblah = abs(Wxy_nonzero_lin(synchPhases));
        synchPowers.(fStr).(chStr) = round(sum(sblah(:))*100)/100;
        ablah = abs(Wxy_nonzero_lin(altPhases));
        altPowers.(fStr).(chStr) = round(sum(ablah(:))*100)/100;
        meanPowers.(fStr).(chStr) = round(mean(abs(Wxy(:)))*100)/100;
        stdPowers.(fStr).(chStr) = round(std(abs(Wxy(:)))*100)/100;
        totalPowers.(fStr).(chStr) = round(sum(abs(Wxy(:))));
        altSynchPowRatio.(fStr).(chStr) = round((altPowers.(fStr).(chStr)/synchPowers.(fStr).(chStr))*100)/100;
        if round(totalPowers.(fStr).(chStr)-(synchPowers.(fStr).(chStr)+ altPowers.(fStr).(chStr)))>10
            errordlg('Synch Pow + Alt Pow ~= Tot Pow');
        end
        if cellNum==2
            firstPow = totalPowers.(fStr).(chStr);
        end
        totPowRatio.(fStr).(chStr) = round(100*totalPowers.(fStr).(chStr)/firstPow)/100;
        statMat(:,cellNum)= deal({pf, meanFreqs.(fStr).(chStr),...
            stdFreqs.(fStr).(chStr),peakPhase.(fStr).(chStr),meanPhases.(fStr).(chStr),...
            stdPhases.(fStr).(chStr),meanPowers.(fStr).(chStr),...
            stdPowers.(fStr).(chStr),synchPowers.(fStr).(chStr),...
            altPowers.(fStr).(chStr),altSynchPowRatio.(fStr).(chStr),totalPowers.(fStr).(chStr),...
            totPowRatio.(fStr).(chStr),num2str(timeRange),num2str(freqRange)});
        chLabelMat{cellNum} = ['f' num2str(fileNum) ' ch' num2str(ch(chNum))...
            num2str(ch(chNum+1))];
        fNamesMat{cellNum} = fNames(fileNum,:);
        
        
        
        %% PLOTTING FIGURES
          if lower(figdisp) =='y' 
                    
            figure('Name', ['XW Power, File ' num2str(fileNum) ', Channels '...
                num2str(ch(chNum)) ' vs ' num2str(ch(chNum+1))],'color','w')
            figPos = get(gcf,'position');
            if strcmpi(powerSpectrumType,'none')
                set(gcf,'position',[figPos(1)*0.6 figPos(2)-figPos(4)/2 figPos(3)*1.3...
                    figPos(4)*2]);
            else
                set(gcf,'position',[figPos(1)*0.6 figPos(2)-figPos(4)/2 figPos(3)* 1.7...
                    figPos(4)*1.5]);
            end
            %% XWT AXES
            ax1 = axes; box off
            aPos = get(ax1,'position');
            if strcmpi(powerSpectrumType,'none')
                aPos = [aPos(1)*0.8 aPos(2)+ aPos(4)*(1/3) aPos(3) aPos(4)*0.75];
            else
                aPos = [aPos(1)*0.8 aPos(2)+ aPos(4)*(1/3) aPos(3)*(0.95) aPos(4)*0.75];
            end
            set(ax1,'position', aPos)
          end  

    
    sig95 = eval(['sig95' num2str(fileNum) 'ch' num2str(chNum) num2str(chNum+1) '']);
    Wxy = eval(['Wf' num2str(fileNum) 'ch' num2str(chNum)...
        num2str(chNum+1) '_coi_sig_alt']);
    
     if lower(figdisp)=='y'     
        plotwave(Wxy,time_reduced,period,coi,sig95,...
            sigmas(fileNum,chNum), sigmas(fileNum,chNum+1))
        set(ax1,'color','k','xtick',[], 'xcolor','w','ycolor','k')
        xlim([time_reduced(1) time_reduced(end)]) %%%% This line is NECESSARY to ensure that x-axis is aligned with traces below
        xlabel('')
        ylims1 = get(ax1,'ylim');
        yticklabels_ax1 = str2num(get(ax1,'yticklabel'));
        dyticklabels_ax1 = diff(yticklabels_ax1);
%         if numel(dyticklabels_ax1)==1,yScale = 'log';
%         elseif dyticklabels_ax1(1)== dyticklabels_ax1(2), yScale = 'linear';
%         else yScale = 'log';
%         end
        yScale = 'log';
        yl = ylabel('Frequency (Hz)','fontsize',14);
        ylpos = get(yl,'pos');
        aPos = get(ax1,'position');
        
        %% XW POWER SPECTRUM AXES
        if strcmpi(powerSpectrumType,'none')
        else
            ax2 = axes; hold on, box off
            aPos2 = get(ax2,'pos');
            aPos2 = [aPos(1) + aPos(3) aPos(2) aPos2(3)*(0.15) aPos(4)];
            set(ax2,'pos', aPos2, 'color','none','tickdir','out','fontsize',11);
            xlabel([{'Normalized'}; {'Power'}])
            if imag(maxtab(:,2))
                maxtab(:,2)= 1+i;
                peakFreqs = 1+i;
            else
                peakFreqs = freq(maxtab(:,1));
            end
            if strcmpi(yScale,'linear')
                logPeakFreqs = peakFreqs;
                freq2 = freq;
            else
                logPeakFreqs = log2(peakFreqs);
                freq2 = log2(freq);
            end
            switch powerSpectrumType
                case 'linear'
                    plot(norm_power_distribution_along_freq_axis.(fStr).(chStr),freq2,'k','linewidth',2)
                    leg = {'Linear Spectrum'}
                case 'log'
                    plot(normlog_power_distribution_along_freq_axis.(fStr).(chStr),freq2,'k','linewidth',2)
                    set(ax2,'xtick',[],'xcolor','w')
                    leg = {'Log Spectrum'};
                    ax2b = axes('position',aPos2,'xaxislocation','bottom',...
                        'yaxislocation','right','color','none','xscale','log','ytick',[],'ycolor','k','fontsize',11);
                    xt = [0.25 0.5 1];
                    set(ax2b,'xtick',xt);
                    xlabel([{'Normalized'}; {'Power'}])
                case 'both'
                    plot(norm_power_distribution_along_freq_axis.(fStr).(chStr), freq2,'k','linewidth',2)
                    plot(normlog_power_distribution_along_freq_axis.(fStr).(chStr), freq2,'k:','linewidth',2,'parent',ax2)
                    leg ={'Linear'; 'Log'};
                    ax2b = axes('position',aPos2,'xaxislocation','top',...
                        'yaxislocation','right','tickdir','out','color','none','xscale','log','ytick',[],'ycolor','w','fontsize',11);
                    xt = [0.25 0.5 1];
                    set(ax2b,'xtick',xt,'xlim',[0 1]);
                    hold off
            end
            
            set(ax2,'ylim',ylims1,'xlim',[0 1],'xtick',[0.5 1],'ytick',[])
            xvals = 0.35*ones(size(peakFreqs));
            
            clear txt
            for pf = 1:length(peakFreqs)
                txt{pf} = [num2str(round(peakFreqs(pf)*100)/100) ' Hz'];
                % txt = {round(peakFreqs*100)/100};
            end
            
            text(xvals,logPeakFreqs,txt,'fontsize',11,'color','r','parent',ax2);
            legend(ax2,leg,'fontsize',10) % This line needs to be here to legend can be moved by hand after fig is generated
            
        end
        
        %% TIME SERIES AXES
        ax3=axes; hold on, box off
        aPos3 = get(ax3,'position');
        aPos3 = [aPos(1) aPos3(2) aPos(3) aPos3(4)*(1/3)];
        set(ax3,'position',aPos3,'tickdir','out','color','w','ycolor','w');
        
        
        switch traceType
            case 'raw'
                fstr = num2str(fileNum);
                tempSig = eval(['temp' num2str(fileNum) '(:,chNum);']);
                tempSig = truncatedata(tempSig,time,[firstTime lastTime]);
                
                tempTime = time; % Adding firstTime to the time vector here
                % will set the time of the first stimulus in the stimulus
                % train to a value of zero
                
                plot(tempTime,tempSig + (yShifter/2)*max(tempSig),'k','linewidth',1.5)
                tempSig = eval(['temp' num2str(fileNum) '(:,chNum+1);']);
                %                 tempSig = zscore(truncatedata(tempSig,time,[firstTime lastTime]));
                tempSig = truncatedata(tempSig,time,[firstTime lastTime]);
                plot(tempTime,tempSig-(yShifter/2)*max(tempSig),...
                    'k','linewidth',1.5)
                
            case 'smooth'
                tempSig(:,chNum) = zscore(sigMat(:,fileNum,chNum));
                tempTime = linspace(firstTime,lastTime,length(tempSig)); % Adding firstTime to the time vector here
                % will set the time of the first stimulus in the stimulus
                % train to a value of zero
                %                 plot(tempTime,tempSig(:,chNum),colors(chNum),'linewidth',1.5)
                plot(tempTime,tempSig(:,chNum)+2.5,'k','linewidth',1.5)
                tempSig(:,chNum+1) = zscore(sigMat(:,fileNum,chNum+1));
                plot(tempTime,tempSig(:,chNum+1)-2.5,'k','linewidth',1.5)
        end
        yl2 = ylabel([{'Normalized'};{'Amplitude'}],'fontsize',14,'color','k');
        ylpos2 = get(yl2,'pos');
        ylpos2_mod = ylpos2;
        ylpos2_mod(1) = tempTime(1)-abs(ylpos(1))+ 0.65; ylpos2_mod(2)=0;
        set(yl2,'pos',ylpos2_mod);
        set(ax3,'ytick',[])
        axis([tempTime(1) tempTime(end) -inf inf])
        set(gca,'fontsize',14)
        switch lower(time_axis_xticks)
            case 'regular'
%                 xtick = fix(linspace(time(1),time(end),10));
%                 dxt = xtick(2)-xtick(1);
%                 xtick = xtick(1):dxt:xtick(end);
%                 set(ax3,'ytick',[],'xtick',xtick)
                  set(ax3,'ytick',[])
            case 'train'
                stimtrain % Running this program generates 'tStimArts' a vector of stimulus artifact times
                xlabel(['Stim Train (' num2str(stimDur) 'sec) @ ' num2str(stimFreq) ' Hz'],'fontsize',14)
                set(ax3,'ytick',[],'xticklabel',[],'xtick',[tStimArts - tStimArts(1)])
                hold off;
        end
     end
 
    
    %% TIME-VARYING MEAN FREQUENCIES AND XW POWERS
    %------- mfvec------------
    Wxy_abs = abs(Wxy);
    maxmat = max(Wxy_abs);
    maxmat = repmat(maxmat,size(Wxy,1),1);
    Wxy_roi = Wxy_abs;
    Wxy_roi(Wxy_roi==0)=-1;
    diffmat = Wxy_roi-maxmat;
    diffmat(diffmat==0)=1;
    diffmat(diffmat<0)=0;
    fmat = repmat(freq(:),1,size(Wxy,2));
    mfmat = diffmat.*fmat;
    mfvec = sum(mfmat);
    mfvec(mfvec==0)=0;
    time_adjusted = time_reduced+firstTime;
    zerotill = min(find(time_adjusted>=0));
    mfvec(1:zerotill)=0; %%%%% This ensures that there are no values in mf prior to the onset of stim train at t = 0.
    %%%%%%% pfvec %%%%%%%%%
    summat = repmat(sum(Wxy_abs),size(Wxy_abs,1),1);
    Wxy_pval = Wxy_abs./summat;
    fmat = repmat(freq(:),1,size(Wxy_abs,2));
    pfmat = fmat.*Wxy_pval;pfvec = sum(pfmat);
    pfvec(pfvec==0)=0;
    zf = find(mfvec==0);
    pfvec(zf)=0;
    pfvec(1:zerotill)=0;
    
    eval(['time_varying_meanfreq_f' num2str(fileNum) 'ch' num2str(chNum)...
        num2str(chNum+1) ' = mfvec;']);
    eval(['time_varying_pfreq_f' num2str(fileNum) 'ch' num2str(chNum)...
        num2str(chNum+1) ' = pfvec;']);
    tvpower = sum(abs(Wxy));
    tvpower(1:zerotill) = 0;
    eval(['time_varying_power_f' num2str(fileNum) 'ch' num2str(chNum)...
        num2str(chNum+1) ' = tvpower;']);
    %         eval(['tvpf_comb' num2str(fileNum) 'ch = tvpower;']);
    eval(['time_varying_power_mat = [time_varying_power_mat; time_varying_power_f' num2str(fileNum) 'ch' num2str(chNum)...
        num2str(chNum+1) '];']);
    
    %% OPTION FOR DYNAMIC FREQ AND PHASE PLOTS
    dynamicfreqpowplot
    end
end
%% STORING STATISTICS IN AN EXCEL FILE
statMat =[chLabelMat; statMat; fNamesMat];
labCompSid = 'S-1-5-21-12604286-656692736-1848903544';
% myLaptopSid = 'S-1-5-21-2395549063-1654931228-1756539298'; % Dell E1505
myLaptopSid = 'S-1-5-21-3197369867-541179473-1092110829'; % Dell XPS
sid =getsid;
strangeCompCheck =0;
switch sid
    case labCompSid
        [success, message] = ...
            xlswrite('C:\Documents and Settings\pujalaav.nih\My Documents/temp.xls',statMat);
        if success
            'Data has been written to temp in My Documents'
        else
            errordlg('Data writing failed! Excel file must be closed for writing data')
        end
    case myLaptopSid
        [success,message]= ...
            xlswrite('C:\Users\Avi\Documents\temp.xls',statMat);
        
        if success
            'Data has been written to temp in My Documents'
        else
            errordlg('Data writing failed! Excel file must be closed for writing data')
        end
    otherwise
        'This is not your lab or home computer, so data has not been written'
        strangeCompCheck = 1;
end

%% OPTION FOR PHASE PLOTS
ButtonName = questdlg('Plot phase distributions?', ...
    'Phase distribution', ...
    'Yes', 'No', 'No');
switch ButtonName,
    case 'Yes',
        plotphase
    case 'No',
end %



%% Pending fixes
% 1) Inscribing 'Power' on colorbar? - I can always do this using 'text'
% function
% 2) Ideally, the two signals need to be normalized using normalizepdf.m
%   provided by Grinsted if the histogram deviates severely from normal.
% 3) Verify logic for stdFreqs
% 4) Since sig regions are affected by length of signal it might be
% beneficial to select a region of the signals from which to calculate
% sigmax and sigmay


% Related Code
% STIMTRAIN - Generates a stim train
% PLOTPHASES - Plots of phase distributions